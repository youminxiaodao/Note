## 如何减少上下文切换

1.无锁并发编程：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以使用一些方法避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据.

2.CAS算法:使用Atomic系列方法来更新数据(CAS算法)，不需要加锁，但在超高并发下，可能导致大量线程竞争不到资源， 而循环进行CAS操作，消耗CPU资源;

3.使用最少线程

4.协程:在单线程里实现多任务的调度，并在单线程里维持多个任务之间的切换.

## 避免死锁的常见方法

1.避免一个线程获取多个锁；

2.避免一个线程在一个锁内同时占用多个资源，尽量保证一个锁一个资源；

3.尝试使用定时锁，tryLock(timeout)来代替使用内部锁机制；

4.对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况.

## 为什么追加64字节能够提高并发编程的效率

因为对于英特尔酷睿i7、酷睿、Atom和NetBrust，以及Core Solo和Pentium M处理器的L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓冲行，这意味着，如果队列的头节点和尾节点都不足64字节的话，处理器会将它们都读到同一个高速缓存行，在处理器下每个处理器都会缓存同样的头、尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其它处理器不能访问自己高速缓存节点中的尾节点，而队列的入队、出队操作则需要不停修改头、尾节点，所以在多处理器的情况下将会严重影响到队列的出队、入队效率。使用追加64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时痐互相锁定。

## 是否在使用volatile变量时都应该追加到64字节?

除了1)缓存行非64字节宽的处理器2)共享变量不会被频繁写外，才需要追加到64字节；

但在JDK7下，可能不会生效。

## Synchronized

1.对于普通同步方法，锁的是当前实例对象；

2.对于静态同步方法，锁的是当前类Class对象；

3.对于同步代码块，锁是synchronized括号里配置的对象.

synchronized在JVM里的实现原理:JVM进入、退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步时使用monitorenter和monitorexit指令实现的，而方法同步时使用另一种方式实现，但在JVM规范中，没有细说。但是方法的同步同样可以使用这两个指令实现。

monitorenter指令试在编译后插入到同步代码块的开始位置，monitorexit是插入方法结束处、异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁.



## Java对象头

synchronized用的锁是存在java对象头里的，如果对象时数组类型，则虚拟机用3个字宽(Word)存储对象头，如果对象时非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit.

32位虚拟机对象头:

![image-20210321172206712](C:\Develop\Git\Note\images\image-20210321172206712.png)

Java对象头里的Mark Word里默认存储对象的HashCod、分代年龄和锁标志。在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化.

![image-20210321172231147](C:\Develop\Git\Note\images\image-20210321172231147.png)

## 锁的升级和变化

### 偏向锁

大多数情况下,锁不仅不存在多线程竞争,而且总是由同一线程多次获得,为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时,会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID,以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁,只需简单地测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。如果测试成功,表示线程已经获得了锁。如果测试失败,则需要再测试一下 Mark Word 中偏向锁的标识是否设置成 1(表示当前是偏向锁):如果没有设置,则使用 CAS 竞争锁;如果设置了,则尝试使用CAS 将对象头的偏向锁指向当前线程。

#### 偏向锁的撤销

偏向锁使用了一种等到竞争出现才释放锁的机制,所以当其他线程尝试竞争偏向锁时,持有偏向锁的线程才会释放锁。偏向锁的撤销,需要等待全局安全点(在这个时间点上没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程,然后检查持有偏向锁的线程是否活着,如果线程不处于活动状态,则将对象头设置成无锁状态;如果线程仍然活着,拥有偏向锁的栈会被执行,遍历偏向对象的锁记录,栈中的锁记录和对象头的Mark Word 要么重新偏向于其他线程,要么恢复到无锁或者标记对象不适合作为偏向锁,最后唤醒暂停的线程。图 2-1 中的线程 1 演示了偏向锁初始化的流程,线程 2 演示了偏向锁撤销的流程。

![image-20210321172833364](C:\Develop\Git\Note\images\image-20210321172833364.png)

#### 关闭偏向锁

偏向锁在 Java 6 和 Java 7 里是默认启用的,但是它在应用程序启动几秒钟之后才激活,如有必要可以使用 JVM 参数来关闭延迟:-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态,可以通过 JVM 参数关闭偏向锁:-XX:- UseBiasedLocking=false,那么程序默认会进入轻量级锁状态。

### 轻量级锁

![image-20210321172928479](C:\Develop\Git\Note\images\image-20210321172928479.png)

#### 轻量级锁加锁

线程在执行同步块之前,JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间,并将对象头中的 Mark Word 复制到锁记录中,官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功,当前线程获得锁,如果失败,表示其他线程竞争锁,当前线程便尝试使用自旋来获取锁。

#### 轻量级锁解锁

轻量级解锁时,会使用原子的 CAS 操作将 Displaced Mark Word 替换回到对象头,如果成功,则表示没有竞争发生。如果失败,表示当前锁存在竞争,锁就会膨胀成重量级锁。图 2-2 是两个线程同时争夺锁,导致锁膨胀的流程图。
因为自旋会消耗 CPU,为了避免无用的自旋(比如获得锁的线程被阻塞住了) ,一旦锁升级成重量级锁,就不会再恢复到轻量级锁状态。当锁处于这个状态下,其他线程试图获取锁时,都会被阻塞住,当持有锁的线程释放锁之后会唤醒这些线程,被唤醒的线程就会进行新一轮的夺锁之争。

#### 锁的优缺点对比

![image-20210321173102968](C:\Develop\Git\Note\images\image-20210321173102968.png)

## 原子操作

### CPU术语

![image-20210321173158388](C:\Develop\Git\Note\images\image-20210321173158388.png)

### 处理器实现原子操作

32 位 IA-32 处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的,意思是当一个处理器读取一个字节时,其他处理器不能访问这个字节的内存地址。Pentium 6 和最新的处理器能自动保证单处理器对同一个缓存行里进行 16/32/64 位的操作是原子的,但是复杂的内存操作处理器是不能自动保证其原子性的,比如跨总线宽度、跨多个缓存行和跨页表的访问。但是,处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。

#### 使用总线锁保证原子性

第一个机制是通过总线锁保证原子性。如果多个处理器同时对共享变量进行读改写操作(i++就是经典的读改写操作),那么共享变量就会被多个处理器同时进行操作,这样读改写操作就不是原子的,操作完之后共享变量的值会和期望的不一致。举个例子,如果 i=1,我们进行两次 i++操作,我们期望的结果是 3,但是有可能结果是 2,如图 2-3所示。

![image-20210321173409396](C:\Develop\Git\Note\images\image-20210321173409396.png)

原因可能是多个处理器同时从各自的缓存中读取变量 i,分别进行加 1 操作,然后分别写入系统内存中。那么,想要保证读改写共享变量的操作是原子的,就必须保证CPU1 读改写共享变量的时候,CPU2 不能操作缓存了该共享变量内存地址的缓存。处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个 LOCK#信号,当一个处理器在总线上输出此信号时,其他处理器的请求将被阻塞住,那么该处理器可以独占共享内存。

#### 使用缓存锁保证原子性

第二个机制是通过缓存锁定来保证原子性。在同一时刻,我们只需保证对某个内存地址的操作是原子性即可,但总线锁定把 CPU 和内存之间的通信锁住了,这使得锁定期间,其他处理器不能操作其他内存地址的数据,所以总线锁定的开销比较大,目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。
频繁使用的内存会缓存在处理器的 L1、L2 和 L3 高速缓存里,那么原子操作就可以直接在处理器内部缓存中进行,并不需要声明总线锁,在 Pentium 6 和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中,并且在 Lock 操作期间被锁定,那么当它执行锁操作回写到内存时,处理器不在总线上声言 LOCK#信号,而是修改内部的内存地址,并允许它的缓存一致性机制来保证操作的原子性,因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据,当其他处理器回写已被锁定的缓存行的数据时,会使缓存行无效,在如图 2-3 所示的例子中,当 CPU1 修改缓存行中的 i 时使用了缓存锁定,那么CPU2 就不能同时缓存 i 的缓存行。

以下两种情况处理器不会使用缓存锁定：

第一种情况是:当操作的数据不能被缓存在处理器内部,或操作的数据跨多个缓存行(cache line)时,则处理器会调用总线锁定。
第二种情况是:有些处理器不支持缓存锁定。对于 Intel 486 和 Pentium 处理器,就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。针对以上两个机制,我们通过 Intel 处理器提供了很多 Lock 前缀的指令来实现。
例如,位测试和修改指令:BTS、BTR、BTC;交换指令 XADD、CMPXCHG,以及其他一些操作数和逻辑指令(如 ADD、OR)等,被这些指令操作的内存区域就会加锁,导致其他处理器不能同时访问它。

### CAS实现原子操作的三大问题

#### ABA问题

#### 循环时间长开销大

#### 只能保证一个共线变量的原子操作

## 指令重排序

1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下,可以重新安排语句的执行顺序。
2. 指令级并行的重排序。现代处理器采用了指令级并行技术(Instruction-LevelParallelism,ILP)来将多条指令重叠执行。如果不存在数据依赖性,处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区,这使得加载和存储操作看上去可能是在乱序执行。

![image-20210321173929200](C:\Develop\Git\Note\images\image-20210321173929200.png)

## 内存屏障

![image-20210321174010093](C:\Develop\Git\Note\images\image-20210321174010093.png)

StoreLoad Barriers 是一个“全能型”的屏障,它同时具有其他 3 个屏障的效果。现代的多处理器大多支持该屏障(其他类型的屏障不一定被所有处理器支持)。执行该屏障开销会很昂贵,因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中(BufferFully Flush)。

## happens-before

## as-if-serial 

as-if-serial 语义的意思是:不管怎么重排序(编译器和处理器为了提高并行度),(单线程)程序的执行结果不能被改变。编译器、runtime 和处理器都必须遵守 as-if-serial 语义。



## 问题

### 缓存一致性协议失效

1.如果一个变量存储长度大于一个缓存行就会导致缓存行失效，可以使用总线锁

2.CPU并不支持缓存一致性协议

### 什么情况下会产生总线风暴？

大量volatile+CAS

### Synchronized在一个方法加锁，另一个方法解锁，如何实现(跨方法)

通过Unsafe类的monitorEnter和monitorExit

![image-20210323204657808](C:\Develop\Git\Note\images\image-20210323204657808.png)

### 如何手动加内存屏障？

通过Unsafe类下的系列方法

![image-20210323204814971](C:\Develop\Git\Note\images\image-20210323204814971.png)



### 为什么通过对象的getClass方法可以获取到Class?

对象头中存储着MetaData元数据指针

### 锁的粗化

### 锁的消除

### 锁的升级

### 锁为什么不能降级

